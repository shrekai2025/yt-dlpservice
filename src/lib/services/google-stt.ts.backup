import * as fs from 'fs/promises'
import axios, { type AxiosRequestConfig } from 'axios'
import { Logger } from '~/lib/utils/logger'
import { ConfigManager } from '~/lib/utils/config'
import { validateAudioFile, getAudioFileInfo } from '~/lib/services/audio-utils'
// 定义服务状态和诊断结果类型
interface ServiceStatus {
  available: boolean
  message: string
}

interface DiagnosisResult {
  success: boolean
  message: string
  details: {
    configCheck: boolean
    credentialsCheck: boolean
    authCheck: boolean
    apiConnectivity: boolean
    suggestions: string[]
  }
}

interface GoogleCredentials {
  type: string
  project_id: string
  private_key_id: string
  private_key: string
  client_email: string
  client_id: string
  auth_uri: string
  token_uri: string
  auth_provider_x509_cert_url: string
  client_x509_cert_url: string
}

interface RecognitionConfig {
  encoding: string
  sampleRateHertz: number
  audioChannelCount: number
  languageCode: string
  alternativeLanguageCodes: string[]
  enableAutomaticPunctuation: boolean
  model: string
}

interface RecognitionAudio {
  content?: string
  uri?: string
}

interface SyncRecognitionRequest {
  config: RecognitionConfig
  audio: RecognitionAudio
}

interface LongRunningRecognitionRequest {
  config: RecognitionConfig
  audio: RecognitionAudio
}

interface SpeechRecognitionAlternative {
  transcript: string
  confidence: number
}

interface SpeechRecognitionResult {
  alternatives: SpeechRecognitionAlternative[]
  languageCode?: string
}

interface SyncRecognitionResponse {
  results: SpeechRecognitionResult[]
  totalBilledTime?: string
  requestId?: string
}

interface Operation {
  name: string
  done: boolean
  error?: {
    code: number
    message: string
  }
  response?: {
    results: SpeechRecognitionResult[]
  }
}

/**
 * Google Speech-to-Text 服务类
 * 
 * 功能特性：
 * - 智能同步/异步选择（10MB为界限）
 * - JWT认证（服务账户密钥）
 * - 复用现有音频处理和轮询逻辑
 * - 多语言支持（中英文自动检测）
 */
class GoogleSpeechService {
  private static instance: GoogleSpeechService
  private projectId: string = ''
  private location: string = 'global'
  private bucketName: string = ''
  private credentials: GoogleCredentials | null = null
  private accessToken: string | null = null
  private tokenExpiration: number = 0

  private constructor() {
    Logger.info('开始初始化Google Speech-to-Text服务...')
  }

  /**
   * 获取代理配置
   */
  private async getProxyConfig(): Promise<any> {
    const proxyEnabled = await ConfigManager.get('GOOGLE_API_PROXY_ENABLED')
    
    if (!proxyEnabled) {
      return false
    }

    const proxyHost = await ConfigManager.get('GOOGLE_API_PROXY_HOST')
    const proxyPort = await ConfigManager.get('GOOGLE_API_PROXY_PORT')

    return {
      host: proxyHost,
      port: proxyPort,
      protocol: 'http'
    }
  }

  /**
   * 上传文件到Google Cloud Storage
   */
  private async uploadToCloudStorage(audioPath: string): Promise<string> {
    try {
      const fileName = `audio-${Date.now()}-${Math.random().toString(36).substring(2)}.mp3`
      const gcsUri = `gs://${this.bucketName}/${fileName}`
      
      Logger.info(`📤 开始上传文件到Cloud Storage: ${fileName}`)
      
      // 读取音频文件
      const fileBuffer = await fs.readFile(audioPath)
      Logger.debug(`📊 文件大小: ${Math.round(fileBuffer.length / 1024 / 1024 * 100) / 100}MB`)
      
      const accessToken = await this.getAccessToken()
      const proxyConfig = await this.getProxyConfig()
      
      // 构建上传请求配置
      const uploadConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'audio/mpeg',
          'Content-Length': fileBuffer.length.toString()
        },
        timeout: 300000, // 5分钟超时
        maxBodyLength: Infinity,
        maxContentLength: Infinity
      }
      
      if (proxyConfig) {
        uploadConfig.proxy = proxyConfig
        Logger.debug(`🌐 使用代理上传: ${proxyConfig.host}:${proxyConfig.port}`)
      }
      
      // 上传到Google Cloud Storage
      const uploadUrl = `https://storage.googleapis.com/upload/storage/v1/b/${this.bucketName}/o?uploadType=media&name=${fileName}`
      
      const startTime = Date.now()
      await axios.put(uploadUrl, fileBuffer, uploadConfig)
      const uploadDuration = Date.now() - startTime
      
      Logger.info(`✅ 文件上传成功: ${gcsUri}`)
      Logger.info(`⏱️ 上传耗时: ${uploadDuration}ms`)
      
      return gcsUri
      
    } catch (error: any) {
      Logger.error(`❌ Cloud Storage上传失败: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTP状态: ${error.response.status}`)
        Logger.error(`  - 响应数据: ${JSON.stringify(error.response.data, null, 2)}`)
      }
      throw new Error(`Cloud Storage上传失败: ${error.message}`)
    }
  }

  /**
   * 删除Cloud Storage中的文件
   */
  private async deleteFromCloudStorage(gcsUri: string): Promise<void> {
    try {
      const fileName = gcsUri.replace(`gs://${this.bucketName}/`, '')
      Logger.debug(`🗑️ 清理Cloud Storage文件: ${fileName}`)
      
      const accessToken = await this.getAccessToken()
      const proxyConfig = await this.getProxyConfig()
      
      const deleteConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        },
        timeout: 30000
      }
      
      if (proxyConfig) {
        deleteConfig.proxy = proxyConfig
      }
      
      const deleteUrl = `https://storage.googleapis.com/storage/v1/b/${this.bucketName}/o/${encodeURIComponent(fileName)}`
      await axios.delete(deleteUrl, deleteConfig)
      
      Logger.debug(`✅ Cloud Storage文件已删除: ${fileName}`)
      
    } catch (error: any) {
      Logger.warn(`⚠️ Cloud Storage文件删除失败: ${error.message}`)
      // 删除失败不影响主流程，只记录警告
    }
  }

  public static getInstance(): GoogleSpeechService {
    if (!GoogleSpeechService.instance) {
      GoogleSpeechService.instance = new GoogleSpeechService()
    }
    return GoogleSpeechService.instance
  }

  /**
   * 初始化服务配置
   */
  private async initialize(): Promise<void> {
    if (this.projectId) {
      Logger.debug('Google Speech服务已初始化')
      return
    }

    try {
      // 加载配置
      const projectId = await ConfigManager.get('GOOGLE_STT_PROJECT_ID')
      const credentialsPath = await ConfigManager.get('GOOGLE_STT_CREDENTIALS_PATH')
      const location = await ConfigManager.get('GOOGLE_STT_LOCATION')
      const bucketName = await ConfigManager.get('GOOGLE_STT_BUCKET_NAME')

      this.location = location || 'global'
      this.bucketName = bucketName || ''

      Logger.info(`Google STT配置状态:`)
      Logger.info(`  - 项目ID: ${projectId ? `${projectId.substring(0, 8)}...` : '未配置'}`)
      Logger.info(`  - 凭据文件: ${credentialsPath || '未配置'}`)
      Logger.info(`  - 位置: ${this.location}`)
      Logger.info(`  - 存储桶: ${this.bucketName || '未配置'}`)

      if (!projectId || !credentialsPath) {
        Logger.error('❌ Google Speech-to-Text API配置不完整，服务不可用！')
        Logger.error('请配置 GOOGLE_STT_PROJECT_ID 和 GOOGLE_STT_CREDENTIALS_PATH')
        return
      }

      if (!this.bucketName) {
        Logger.warn('⚠️ Google Cloud Storage存储桶未配置，大文件(>=10MB)将无法处理')
        Logger.warn('请配置 GOOGLE_STT_BUCKET_NAME 以支持大文件转录')
      }

      // 加载服务账户凭据
      await this.loadCredentials(credentialsPath)
      this.projectId = projectId

      if (this.credentials) {
        Logger.info('✅ Google Speech-to-Text API配置完成')
        
        // 测试网络连接
        Logger.debug('🌐 测试Google API网络连通性...')
        try {
          const testStart = Date.now()
          const proxyConfig = await this.getProxyConfig()
          const testRequestConfig: any = {
            timeout: 5000,
            validateStatus: () => true // 接受任何状态码
          }

          if (proxyConfig) {
            testRequestConfig.proxy = proxyConfig
          }

          const response = await axios.get('https://www.googleapis.com', testRequestConfig)
          const connectTime = Date.now() - testStart
          Logger.debug(`✅ Google API网络连通正常，延迟: ${connectTime}ms`)
          Logger.debug(`  - 状态码: ${response.status}`)
        } catch (networkError: any) {
          Logger.warn(`⚠️ Google API网络连接测试失败: ${networkError.message}`)
          Logger.warn(`  - 这可能会影响后续的认证和API调用`)
          if (networkError.code === 'ENOTFOUND') {
            Logger.warn(`  - DNS解析失败，请检查网络连接`)
          } else if (networkError.code === 'ECONNREFUSED') {
            Logger.warn(`  - 连接被拒绝，可能是网络防火墙问题`)
          } else if (networkError.code === 'ETIMEDOUT') {
            Logger.warn(`  - 连接超时，网络延迟较高`)
          }
        }
      }

    } catch (error: any) {
      Logger.error(`Google Speech服务初始化失败: ${error.message}`)
      throw new Error(`Google Speech服务初始化失败: ${error.message}`)
    }
  }

  /**
   * 加载Google服务账户凭据
   */
  private async loadCredentials(credentialsPath: string): Promise<void> {
    try {
      Logger.debug(`📁 尝试读取凭据文件: ${credentialsPath}`)
      
      // 检查文件是否存在
      try {
        await fs.access(credentialsPath)
        Logger.debug(`✅ 凭据文件存在`)
      } catch (accessError) {
        throw new Error(`凭据文件不存在: ${credentialsPath}`)
      }
      
      const credentialsContent = await fs.readFile(credentialsPath, 'utf-8')
      Logger.debug(`📄 凭据文件读取成功，内容长度: ${credentialsContent.length}字符`)
      
      // 解析JSON
      let parsedCredentials: any
      try {
        parsedCredentials = JSON.parse(credentialsContent)
        Logger.debug(`✅ JSON解析成功`)
      } catch (parseError) {
        throw new Error(`凭据文件JSON格式错误: ${parseError}`)
      }
      
      this.credentials = parsedCredentials as GoogleCredentials
      
      Logger.debug(`✅ Google服务账户凭据加载成功: ${this.credentials.client_email}`)
      Logger.debug(`📋 凭据信息:`)
      Logger.debug(`  - 类型: ${this.credentials.type}`)
      Logger.debug(`  - 项目ID: ${this.credentials.project_id}`)
      Logger.debug(`  - 客户端邮箱: ${this.credentials.client_email}`)
      Logger.debug(`  - 客户端ID: ${this.credentials.client_id}`)
      Logger.debug(`  - 私钥ID: ${this.credentials.private_key_id}`)
      Logger.debug(`  - 认证URI: ${this.credentials.auth_uri}`)
      Logger.debug(`  - Token URI: ${this.credentials.token_uri}`)
      
      // 验证必要字段
      const requiredFields = ['private_key', 'client_email', 'project_id', 'token_uri']
      const missingFields = requiredFields.filter(field => !this.credentials![field as keyof GoogleCredentials])
      
      if (missingFields.length > 0) {
        throw new Error(`服务账户凭据缺少必要字段: ${missingFields.join(', ')}`)
      }
      
      // 验证私钥格式
      if (!this.credentials.private_key.includes('-----BEGIN PRIVATE KEY-----')) {
        throw new Error('私钥格式不正确')
      }
      
      Logger.debug(`✅ 凭据验证通过`)

    } catch (error: any) {
      Logger.error(`❌ 加载Google凭据失败: ${error.message}`)
      if (error.code === 'ENOENT') {
        Logger.error(`  - 文件路径: ${credentialsPath}`)
        Logger.error(`  - 请确保凭据文件存在且路径正确`)
      }
      throw new Error(`加载Google凭据失败: ${error.message}`)
    }
  }

  /**
   * 获取Google Access Token (JWT认证)
   */
  private async getAccessToken(): Promise<string> {
    // 如果token还未过期，直接返回
    if (this.accessToken && Date.now() < this.tokenExpiration) {
      return this.accessToken
    }

    return await this.refreshAccessToken()
  }

  /**
   * 刷新Access Token
   */
  private async refreshAccessToken(): Promise<string> {
    if (!this.credentials) {
      throw new Error('Google凭据未加载')
    }

    try {
      Logger.debug('🔐 开始获取Google Access Token...')
      Logger.debug(`🔑 使用服务账户: ${this.credentials.client_email}`)
      Logger.debug(`📋 项目ID: ${this.credentials.project_id}`)

      // 生成JWT
      Logger.debug('🔧 生成JWT Token...')
      const jwt = await this.generateJWT()
      Logger.debug(`✅ JWT生成成功，长度: ${jwt.length}字符`)

      // 请求access token
      Logger.debug('📡 发送OAuth请求到Google...')
      const startTime = Date.now()
      
      const proxyConfig = await this.getProxyConfig()
      const requestConfig: any = {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        timeout: 30000
      }

      if (proxyConfig) {
        requestConfig.proxy = proxyConfig
        Logger.debug(`🌐 使用代理: ${proxyConfig.host}:${proxyConfig.port}`)
      }

      const response = await axios.post('https://oauth2.googleapis.com/token', {
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
        assertion: jwt
      }, requestConfig)

      const requestDuration = Date.now() - startTime
      Logger.debug(`📡 OAuth请求完成，耗时: ${requestDuration}ms`)

      const { access_token, expires_in } = response.data
      
      this.accessToken = access_token
      this.tokenExpiration = Date.now() + (expires_in * 1000) - 60000 // 提前1分钟过期

      Logger.debug(`✅ Google Access Token获取成功`)
      Logger.debug(`  - Token长度: ${access_token.length}字符`)
      Logger.debug(`  - 有效期: ${expires_in}秒`)
      Logger.debug(`  - 过期时间: ${new Date(this.tokenExpiration).toLocaleString()}`)
      
      return access_token

    } catch (error: any) {
      Logger.error(`❌ 获取Google Access Token失败: ${error.message}`)
      
      // 详细错误信息
      if (error.code) {
        Logger.error(`  - 错误代码: ${error.code}`)
      }
      if (error.response) {
        Logger.error(`  - HTTP状态: ${error.response.status}`)
        Logger.error(`  - 响应数据:`, error.response.data)
      }
      if (error.request) {
        Logger.error(`  - 请求配置:`, {
          url: error.request.responseURL || error.config?.url,
          method: error.config?.method,
          timeout: error.config?.timeout
        })
      }
      
      throw new Error(`Google认证失败: ${error.message}`)
    }
  }

  /**
   * 生成JWT Token
   */
  private async generateJWT(): Promise<string> {
    if (!this.credentials) {
      throw new Error('Google凭据未加载')
    }

    try {
      Logger.debug('🔧 开始生成JWT Token...')
      
      const now = Math.floor(Date.now() / 1000)
      const header = {
        alg: 'RS256',
        typ: 'JWT'
      }

      const payload = {
        iss: this.credentials.client_email,
        scope: 'https://www.googleapis.com/auth/cloud-platform',
        aud: 'https://oauth2.googleapis.com/token',
        exp: now + 3600, // 1小时过期
        iat: now
      }

      Logger.debug(`📋 JWT Payload:`)
      Logger.debug(`  - 签发者: ${payload.iss}`)
      Logger.debug(`  - 权限范围: ${payload.scope}`)
      Logger.debug(`  - 目标受众: ${payload.aud}`)
      Logger.debug(`  - 签发时间: ${new Date(payload.iat * 1000).toISOString()}`)
      Logger.debug(`  - 过期时间: ${new Date(payload.exp * 1000).toISOString()}`)

      // 使用Node.js内置crypto模块生成JWT
      const crypto = require('crypto')
      
      Logger.debug('🔧 编码JWT头部和载荷...')
      const headerBase64 = Buffer.from(JSON.stringify(header)).toString('base64url')
      const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString('base64url')
      
      const signatureInput = `${headerBase64}.${payloadBase64}`
      Logger.debug(`📝 待签名字符串长度: ${signatureInput.length}字符`)
      
      // 清理private key格式
      Logger.debug('🔑 处理私钥格式...')
      const privateKey = this.credentials.private_key.replace(/\\n/g, '\n')
      Logger.debug(`🔑 私钥长度: ${privateKey.length}字符`)
      
      // 验证私钥格式
      if (!privateKey.includes('-----BEGIN PRIVATE KEY-----')) {
        throw new Error('私钥格式不正确，缺少BEGIN标记')
      }
      if (!privateKey.includes('-----END PRIVATE KEY-----')) {
        throw new Error('私钥格式不正确，缺少END标记')
      }
      
      Logger.debug('🔏 生成RSA-SHA256签名...')
      const signature = crypto.sign('RSA-SHA256', Buffer.from(signatureInput), {
        key: privateKey,
        padding: crypto.constants.RSA_PKCS1_PADDING
      })
      
      const signatureBase64 = signature.toString('base64url')
      Logger.debug(`✅ 签名生成成功，长度: ${signatureBase64.length}字符`)
      
      const jwt = `${signatureInput}.${signatureBase64}`
      Logger.debug(`✅ JWT生成完成，总长度: ${jwt.length}字符`)
      
      return jwt
      
    } catch (error: any) {
      Logger.error(`❌ JWT生成失败: ${error.message}`)
      if (error.stack) {
        Logger.error(`  - 堆栈信息: ${error.stack}`)
      }
      throw new Error(`JWT生成失败: ${error.message}`)
    }
  }

  /**
   * 判断是否使用同步识别（10MB为界限）
   */
  private shouldUseSyncRecognition(fileSize?: number): boolean {
    const SYNC_THRESHOLD_BYTES = 10 * 1024 * 1024 // 10MB

    // 如果无法获取文件大小信息，默认使用同步
    if (!fileSize) {
      Logger.info('🔄 无法获取音频文件大小，默认使用同步识别')
      return true
    }

    const fileSizeMB = Math.round(fileSize / 1024 / 1024 * 100) / 100
    
    // 如果文件大小超过10MB但没有配置存储桶，强制使用同步（会失败，但给出明确错误）
    if (fileSize > SYNC_THRESHOLD_BYTES && !this.bucketName) {
      Logger.error(`❌ 文件大小${fileSizeMB}MB超过10MB限制，但未配置Cloud Storage存储桶`)
      Logger.error('请配置 GOOGLE_STT_BUCKET_NAME 环境变量以支持大文件转录')
      throw new Error(`文件大小${fileSizeMB}MB超过10MB限制，需要配置Google Cloud Storage`)
    }
    
    const useSync = fileSize <= SYNC_THRESHOLD_BYTES
    Logger.info(`🎯 音频文件大小: ${fileSizeMB}MB, 选择${useSync ? '同步' : '异步(Cloud Storage)'}识别`)
    return useSync
  }

  /**
   * 同步语音识别（小文件，<10MB）
   */
  private async syncRecognize(audioPath: string): Promise<string> {
    try {
      Logger.info(`🎤 开始Google同步语音识别: ${audioPath}`)

      const accessToken = await this.getAccessToken()
      
      // 读取并编码音频文件
      const audioBuffer = await fs.readFile(audioPath)
      const base64Audio = audioBuffer.toString('base64')
      Logger.info(`📦 音频编码完成，大小: ${Math.round(audioBuffer.length / 1024 / 1024 * 100) / 100}MB`)

      // 构建请求
      const request: SyncRecognitionRequest = {
        config: this.buildRecognitionConfig(false),
        audio: {
          content: base64Audio
        }
      }

      Logger.info(`🚀 提交Google同步识别任务...`)
      Logger.debug(`  - 语言: ${request.config.languageCode}`)
      Logger.debug(`  - 模型: ${request.config.model}`)
      Logger.debug(`  - 采样率: ${request.config.sampleRateHertz}Hz`)

      const proxyConfig = await this.getProxyConfig()
      const requestConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        timeout: 300000 // 5分钟超时
      }
      
      if (proxyConfig) {
        requestConfig.proxy = proxyConfig
      }

      const startTime = Date.now()
      const response = await axios.post<SyncRecognitionResponse>(
        'https://speech.googleapis.com/v1/speech:recognize',
        request,
        requestConfig
      )

      const duration = Date.now() - startTime
      Logger.info(`📦 Google同步识别响应接收完成，耗时: ${duration}ms`)

      // 解析结果
      const transcription = this.parseRecognitionResponse(response.data)
      Logger.info(`✅ Google同步语音识别成功 - 文本长度: ${transcription.length}字符`)
      
      return transcription

    } catch (error: any) {
      Logger.error(`❌ Google同步语音识别失败: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTP状态: ${error.response.status}`)
        Logger.error(`  - 响应数据: ${JSON.stringify(error.response.data, null, 2)}`)
      }
      throw new Error(`Google同步语音识别失败: ${error.message}`)
    }
  }

  /**
   * 异步语音识别（大文件，>=10MB，使用Cloud Storage）
   */
  private async longRunningRecognize(audioPath: string): Promise<string> {
    let gcsUri: string | null = null
    
    try {
      Logger.info(`🎤 开始Google异步语音识别: ${audioPath}`)

      // 上传文件到Cloud Storage
      gcsUri = await this.uploadToCloudStorage(audioPath)
      
      const accessToken = await this.getAccessToken()
      
      // 构建请求
      const request: LongRunningRecognitionRequest = {
        config: this.buildRecognitionConfig(true),
        audio: {
          uri: gcsUri
        }
      }

      Logger.info(`🚀 提交Google异步识别任务...`)
      Logger.debug(`  - 语言: ${request.config.languageCode}`)
      Logger.debug(`  - 模型: ${request.config.model}`)
      Logger.debug(`  - Cloud Storage URI: ${gcsUri}`)

      const proxyConfig = await this.getProxyConfig()
      const requestConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        timeout: 300000 // 5分钟超时
      }
      
      if (proxyConfig) {
        requestConfig.proxy = proxyConfig
      }

      const startTime = Date.now()
      const response = await axios.post<Operation>(
        'https://speech.googleapis.com/v1/speech:longrunningrecognize',
        request,
        requestConfig
      )

      const duration = Date.now() - startTime
      Logger.info(`📦 Google异步任务提交成功，耗时: ${duration}ms`)
      Logger.info(`  - 操作名称: ${response.data.name}`)

      // 轮询等待结果
      const operationName = response.data.name
      const result = await this.pollLongRunningOperation(operationName)
      
      // 解析结果
      if (!result.response?.results) {
        throw new Error('异步识别操作完成，但没有返回识别结果')
      }
      
      const transcription = this.parseRecognitionResponse(result.response)
      Logger.info(`✅ Google异步语音识别成功 - 文本长度: ${transcription.length}字符`)
      
      return transcription

    } catch (error: any) {
      Logger.error(`❌ Google异步语音识别失败: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTP状态: ${error.response.status}`)
        Logger.error(`  - 响应数据: ${JSON.stringify(error.response.data, null, 2)}`)
      }
      throw new Error(`Google异步语音识别失败: ${error.message}`)
    } finally {
      // 清理Cloud Storage文件
      if (gcsUri) {
        try {
          await this.deleteFromCloudStorage(gcsUri)
        } catch (cleanupError) {
          Logger.warn(`⚠️ 清理Cloud Storage文件失败: ${cleanupError}`)
        }
      }
    }
  }

  /**
   * 轮询长运行操作状态
   */
  private async pollLongRunningOperation(operationName: string): Promise<Operation> {
    const maxAttempts = 60 // 最大轮询次数
    const initialDelay = 5000 // 初始延迟5秒
    const maxDelay = 30000 // 最大延迟30秒
    
    Logger.info(`🔄 开始轮询异步操作状态: ${operationName}`)
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const operation = await this.queryOperation(operationName)
        
        if (operation.done) {
          if (operation.error) {
            Logger.error(`❌ 异步操作失败: ${JSON.stringify(operation.error)}`)
            throw new Error(`异步操作失败: ${operation.error.message || '未知错误'}`)
          }
          
          Logger.info(`✅ 异步操作完成，共轮询${attempt}次`)
          return operation
        }
        
        // 计算动态延迟时间（指数退避）
        const delay = Math.min(initialDelay * Math.pow(1.5, attempt - 1), maxDelay)
        Logger.debug(`⏳ 操作未完成，${delay}ms后进行第${attempt + 1}次查询...`)
        
        await new Promise(resolve => setTimeout(resolve, delay))
        
      } catch (error: any) {
        Logger.error(`❌ 查询操作状态失败(第${attempt}次): ${error.message}`)
        
        if (attempt === maxAttempts) {
          throw new Error(`轮询操作状态失败，已达到最大重试次数: ${error.message}`)
        }
        
        // 查询失败时等待较短时间再重试
        await new Promise(resolve => setTimeout(resolve, 2000))
      }
    }
    
    throw new Error(`异步操作超时，已轮询${maxAttempts}次仍未完成`)
  }

  /**
   * 查询异步操作状态
   */
  private async queryOperation(operationName: string): Promise<Operation> {
    const accessToken = await this.getAccessToken()
    const proxyConfig = await this.getProxyConfig()
    
    const requestConfig: any = {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000 // 30秒超时
    }
    
    if (proxyConfig) {
      requestConfig.proxy = proxyConfig
    }

    const response = await axios.get<Operation>(
      `https://speech.googleapis.com/v1/${operationName}`,
      requestConfig
    )

    return response.data
  }

  /**
   * 构建识别配置
   */
  private buildRecognitionConfig(isLongRunning: boolean = false): RecognitionConfig {
    return {
      encoding: 'MP3',
      sampleRateHertz: 16000,
      audioChannelCount: 1,
      languageCode: 'zh-CN',
      alternativeLanguageCodes: ['en-US', 'ja-JP'], // 支持中英日文
      enableAutomaticPunctuation: true,
      model: isLongRunning ? 'latest_long' : 'latest_short'
    }
  }


  /**
   * 解析识别响应结果
   */
  private parseRecognitionResponse(response: SyncRecognitionResponse | { results: SpeechRecognitionResult[] }): string {
    try {
      // 获取访问令牌
      const accessToken = await this.getAccessToken()

      // 读取和编码音频文件
      const audioBuffer = await fs.readFile(audioPath)
      const audioContent = audioBuffer.toString('base64')

      Logger.info(`📦 音频编码完成，大小: ${Math.round(audioBuffer.length / 1024 / 1024 * 100) / 100}MB`)

      const request: LongRunningRecognitionRequest = {
        config: this.buildRecognitionConfig(true),
        audio: { content: audioContent }
      }

      Logger.info(`🚀 提交Google异步识别任务...`)
      Logger.debug(`  - 语言: ${request.config.languageCode}`)
      Logger.debug(`  - 模型: ${request.config.model}`)

      const startTime = Date.now()
      const response = await axios.post<Operation>(
        'https://speech.googleapis.com/v1/speech:longrunningrecognize',
        request,
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          timeout: 300000, // 5分钟超时
          proxy: {
            host: '127.0.0.1',
            port: 7890,
            protocol: 'http'
          }
        }
      )

      const duration = Date.now() - startTime
      Logger.info(`📦 Google异步任务提交成功，耗时: ${duration}ms`)
      Logger.info(`  - 操作名称: ${response.data.name}`)

      return response.data.name

    } catch (error: any) {
      Logger.error(`❌ 提交Google异步任务失败: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTP状态: ${error.response.status}`)
        Logger.error(`  - 响应数据:`, error.response.data)
      }
      throw new Error(`提交Google异步任务失败: ${error.message}`)
    }
  }

  /**
   * 轮询异步操作结果（复用豆包的轮询策略）
   */
  private async pollLongRunningOperation(operationName: string): Promise<string> {
    const maxRetries = 80 // 80次轮询
    const baseInterval = 30000 // 30秒基础间隔
    const maxWaitTime = maxRetries * baseInterval

    Logger.info(`🔄 开始轮询Google Speech异步任务:`)
    Logger.info(`  - 操作名称: ${operationName}`)
    Logger.info(`  - 最大轮询次数: ${maxRetries}`)
    Logger.info(`  - 轮询间隔: ${baseInterval/1000}秒`)
    Logger.info(`  - 最大等待时间: ${Math.round(maxWaitTime/60000)}分钟`)

    for (let i = 0; i < maxRetries; i++) {
      // 复用豆包的动态间隔逻辑：前5次快速，后续正常
      const currentInterval = i < 5 ? Math.max(baseInterval / 2, 15000) : baseInterval
      await new Promise(resolve => setTimeout(resolve, currentInterval))

      const progress = Math.round((i + 1) / maxRetries * 100)
      Logger.info(`📊 查询Google异步任务状态 (${i + 1}/${maxRetries}, ${progress}%): 间隔: ${currentInterval}ms`)

      try {
        const startTime = Date.now()
        const operation = await this.queryOperation(operationName)
        const queryTime = Date.now() - startTime

        Logger.debug(`🔍 查询响应时间: ${queryTime}ms`)

        if (operation.done) {
          if (operation.error) {
            Logger.error(`💥 Google异步任务失败:`)
            Logger.error(`  - 错误代码: ${operation.error.code}`)
            Logger.error(`  - 错误消息: ${operation.error.message}`)
            throw new Error(`Google异步任务失败: ${operation.error.message}`)
          }

          if (operation.response) {
            const transcription = this.parseRecognitionResponse(operation.response)
            
            const totalElapsedTime = (i + 1) * currentInterval
            Logger.info(`🎉 Google异步任务完成:`)
            Logger.info(`  - 轮询次数: ${i + 1}/${maxRetries}`)
            Logger.info(`  - 总耗时: ${Math.round(totalElapsedTime / 1000)}秒`)
            Logger.info(`  - 转录长度: ${transcription.length}字符`)
            Logger.info(`  - 转录预览: ${transcription.substring(0, 300)}${transcription.length > 300 ? '...' : ''}`)

            return transcription
          }
        }

        Logger.info(`📈 Google异步任务进行中 (${i + 1}/${maxRetries})`)

      } catch (error: any) {
        Logger.warn(`⏰ Google查询出错，将进行重试 (${i + 1}/${maxRetries}): ${error.message}`)
        
        // 如果连续多次失败，抛出错误
        if (i >= 5 && error.message.includes('认证') || error.message.includes('授权')) {
          throw error
        }
      }
    }

    Logger.error(`💀 Google异步识别任务超时:`)
    Logger.error(`  - 操作名称: ${operationName}`)
    Logger.error(`  - 已等待时间: ${Math.round(maxWaitTime/60000)}分钟`)
    
    throw new Error(`Google异步语音识别任务超时，已等待${Math.round(maxWaitTime/60000)}分钟`)
  }

  /**
   * 查询异步操作状态
   */
  private async queryOperation(operationName: string): Promise<Operation> {
    const accessToken = await this.getAccessToken()

    const response = await axios.get<Operation>(
      `https://speech.googleapis.com/v1/${operationName}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        timeout: 30000, // 30秒超时
        proxy: {
          host: '127.0.0.1',
          port: 1080,
          protocol: 'http'
        }
      }
    )

    return response.data
  }

  /**
   * 解析识别响应结果
   */
  private parseRecognitionResponse(response: SyncRecognitionResponse | { results: SpeechRecognitionResult[] }): string {
    if (!response.results || response.results.length === 0) {
      Logger.warn('Google Speech返回空结果')
      return ''
    }

    // 合并所有results中的最佳转录结果
    const transcription = response.results
      .map(result => {
        const alternative = result.alternatives?.[0]
        if (alternative && alternative.transcript) {
          // 记录置信度信息
          if (alternative.confidence) {
            Logger.debug(`转录片段置信度: ${(alternative.confidence * 100).toFixed(1)}%`)
          }
          return alternative.transcript
        }
        return ''
      })
      .filter(text => text.length > 0)
      .join(' ')
      .trim()

    Logger.info(`📝 Google Speech转录结果解析完成: ${transcription.length}字符`)
    
    if (transcription.length === 0) {
      Logger.warn('⚠️ 解析后的转录结果为空')
    }

    return transcription
  }

  /**
   * 主入口：语音转文字
   */
  public async speechToText(audioPath: string): Promise<string> {
    try {
      Logger.info(`🎤 开始Google Speech语音识别: ${audioPath}`)

      // 初始化服务
      await this.initialize()

      if (!this.projectId || !this.credentials) {
        throw new Error('Google Speech服务未正确初始化')
      }

      // 验证音频文件
      const isValid = await validateAudioFile(audioPath)
      if (!isValid) {
        throw new Error('音频文件验证失败')
      }

      // 获取音频信息
      const audioInfo = await getAudioFileInfo(audioPath)
      Logger.info(`📊 音频文件信息:`)
      Logger.info(`  - 时长: ${audioInfo.duration ? `${audioInfo.duration}秒` : '未知'}`)
      Logger.info(`  - 大小: ${Math.round(audioInfo.size / 1024 / 1024 * 100) / 100}MB`)
      Logger.info(`  - 格式: ${audioInfo.format}`)

      // 智能选择同步或异步识别（基于文件大小）
      const useSync = this.shouldUseSyncRecognition(audioInfo.size)

      let transcription: string
      if (useSync) {
        transcription = await this.syncRecognize(audioPath)
      } else {
        transcription = await this.longRunningRecognize(audioPath)
      }

      if (!transcription || transcription.trim().length === 0) {
        Logger.error(`❌ Google Speech识别结果为空`)
        throw new Error('语音识别结果为空')
      }

      Logger.info(`✅ Google Speech语音识别成功 - 文本长度: ${transcription.length}字符`)
      return transcription

    } catch (error: any) {
      Logger.error(`❌ Google Speech语音转录失败: ${error.message}`)
      Logger.error(`🔧 错误详情: ${error.stack || 'No stack trace'}`)
      throw error
    }
  }

  /**
   * 检查服务状态
   */
  public async checkServiceStatus(): Promise<ServiceStatus> {
    try {
      await this.initialize()
      
      if (!this.projectId) {
        return { 
          available: false, 
          message: 'Google Speech项目ID未配置' 
        }
      }

      if (!this.credentials) {
        return { 
          available: false, 
          message: 'Google Speech凭据文件未加载' 
        }
      }

      // 尝试获取访问令牌
      const token = await this.getAccessToken()
      if (!token) {
        return { 
          available: false, 
          message: 'Google Speech认证失败' 
        }
      }

      return { 
        available: true, 
        message: 'Google Speech服务配置正确' 
      }

    } catch (error: any) {
      return { 
        available: false, 
        message: `Google Speech服务不可用: ${error.message}` 
      }
    }
  }

  /**
   * 诊断Google Speech服务
   */
  public async diagnoseService(): Promise<DiagnosisResult> {
    const details = {
      configCheck: false,
      credentialsCheck: false,
      authCheck: false,
      apiConnectivity: false,
      suggestions: [] as string[]
    }

    let success = false

    try {
      Logger.info(`🔧 开始Google Speech诊断...`)

      // 1. 配置检查
      try {
        const projectId = await ConfigManager.get('GOOGLE_STT_PROJECT_ID')
        const credentialsPath = await ConfigManager.get('GOOGLE_STT_CREDENTIALS_PATH')

        if (!projectId) {
          details.suggestions.push('请配置 GOOGLE_STT_PROJECT_ID')
        }
        if (!credentialsPath) {
          details.suggestions.push('请配置 GOOGLE_STT_CREDENTIALS_PATH')
        }

        details.configCheck = !!(projectId && credentialsPath)
        Logger.info(`✅ 配置检查: ${details.configCheck ? '通过' : '失败'}`)

      } catch (error: any) {
        Logger.error(`💥 配置检查失败: ${error.message}`)
        details.suggestions.push('检查环境变量配置')
      }

      // 2. 凭据文件检查
      if (details.configCheck) {
        try {
          const credentialsPath = await ConfigManager.get('GOOGLE_STT_CREDENTIALS_PATH')
          await this.loadCredentials(credentialsPath!)
          details.credentialsCheck = true
          Logger.info(`✅ 凭据文件检查: 通过`)

        } catch (error: any) {
          Logger.error(`💥 凭据文件检查失败: ${error.message}`)
          details.suggestions.push('检查Google服务账户凭据文件是否存在且格式正确')
        }
      }

      // 3. 认证检查
      if (details.credentialsCheck) {
        try {
          const token = await this.getAccessToken()
          details.authCheck = !!token
          Logger.info(`✅ 认证检查: ${details.authCheck ? '通过' : '失败'}`)

        } catch (error: any) {
          Logger.error(`💥 认证检查失败: ${error.message}`)
          details.suggestions.push('检查Google Cloud项目权限和服务账户配置')
        }
      }

      // 4. API连通性检查
      if (details.authCheck) {
        try {
          const accessToken = await this.getAccessToken()
          
          // 发送一个简单的请求测试连通性
          await axios.get('https://speech.googleapis.com/v1/operations', {
            headers: {
              'Authorization': `Bearer ${accessToken}`
            },
            timeout: 15000,
            proxy: {
              host: '127.0.0.1',
              port: 7890,
              protocol: 'http'
            }
          })

          details.apiConnectivity = true
          Logger.info(`✅ API连通性检查: 通过`)

        } catch (error: any) {
          Logger.error(`💥 API连通性检查失败: ${error.message}`)
          details.suggestions.push('检查网络连接和Google Cloud Speech API是否已启用')
        }
      }

      success = details.configCheck && details.credentialsCheck && details.authCheck && details.apiConnectivity

      const resultMessage = success ? '✅ Google Speech诊断全部通过' : '⚠️ 发现问题，请查看详细信息'
      
      Logger.info(`🎯 Google Speech诊断完成: ${success ? '成功' : '失败'}`)

      return {
        success,
        message: resultMessage,
        details
      }

    } catch (error: any) {
      Logger.error(`💀 Google Speech诊断过程出错: ${error.message}`)
      
      return {
        success: false,
        message: `Google Speech诊断失败: ${error.message}`,
        details
      }
    }
  }
}

export default GoogleSpeechService
