import * as fs from 'fs/promises'
import axios, { type AxiosRequestConfig } from 'axios'
import { Logger } from '~/lib/utils/logger'
import { ConfigManager } from '~/lib/utils/config'
import { validateAudioFile, getAudioFileInfo } from '~/lib/services/audio-utils'
// å®šä¹‰æœåŠ¡çŠ¶æ€å’Œè¯Šæ–­ç»“æœç±»å‹
interface ServiceStatus {
  available: boolean
  message: string
}

interface DiagnosisResult {
  success: boolean
  message: string
  details: {
    configCheck: boolean
    credentialsCheck: boolean
    authCheck: boolean
    apiConnectivity: boolean
    suggestions: string[]
  }
}

interface GoogleCredentials {
  type: string
  project_id: string
  private_key_id: string
  private_key: string
  client_email: string
  client_id: string
  auth_uri: string
  token_uri: string
  auth_provider_x509_cert_url: string
  client_x509_cert_url: string
}

interface RecognitionConfig {
  encoding: string
  sampleRateHertz: number
  audioChannelCount: number
  languageCode: string
  alternativeLanguageCodes: string[]
  enableAutomaticPunctuation: boolean
  model: string
}

interface RecognitionAudio {
  content?: string
  uri?: string
}

interface SyncRecognitionRequest {
  config: RecognitionConfig
  audio: RecognitionAudio
}

interface LongRunningRecognitionRequest {
  config: RecognitionConfig
  audio: RecognitionAudio
}

interface SpeechRecognitionAlternative {
  transcript: string
  confidence: number
}

interface SpeechRecognitionResult {
  alternatives: SpeechRecognitionAlternative[]
  languageCode?: string
}

interface SyncRecognitionResponse {
  results: SpeechRecognitionResult[]
  totalBilledTime?: string
  requestId?: string
}

interface Operation {
  name: string
  done: boolean
  error?: {
    code: number
    message: string
  }
  response?: {
    results: SpeechRecognitionResult[]
  }
}

/**
 * Google Speech-to-Text æœåŠ¡ç±»
 * 
 * åŠŸèƒ½ç‰¹æ€§ï¼š
 * - æ™ºèƒ½åŒæ­¥/å¼‚æ­¥é€‰æ‹©ï¼ˆ10MBä¸ºç•Œé™ï¼‰
 * - JWTè®¤è¯ï¼ˆæœåŠ¡è´¦æˆ·å¯†é’¥ï¼‰
 * - å¤ç”¨ç°æœ‰éŸ³é¢‘å¤„ç†å’Œè½®è¯¢é€»è¾‘
 * - å¤šè¯­è¨€æ”¯æŒï¼ˆä¸­è‹±æ–‡è‡ªåŠ¨æ£€æµ‹ï¼‰
 */
class GoogleSpeechService {
  private static instance: GoogleSpeechService
  private projectId: string = ''
  private location: string = 'global'
  private bucketName: string = ''
  private credentials: GoogleCredentials | null = null
  private accessToken: string | null = null
  private tokenExpiration: number = 0

  private constructor() {
    Logger.info('å¼€å§‹åˆå§‹åŒ–Google Speech-to-TextæœåŠ¡...')
  }

  /**
   * è·å–ä»£ç†é…ç½®
   */
  private async getProxyConfig(): Promise<any> {
    const proxyEnabled = await ConfigManager.get('GOOGLE_API_PROXY_ENABLED')
    
    if (!proxyEnabled) {
      return false
    }

    const proxyHost = await ConfigManager.get('GOOGLE_API_PROXY_HOST')
    const proxyPort = await ConfigManager.get('GOOGLE_API_PROXY_PORT')

    return {
      host: proxyHost,
      port: proxyPort,
      protocol: 'http'
    }
  }

  /**
   * ä¸Šä¼ æ–‡ä»¶åˆ°Google Cloud Storage
   */
  private async uploadToCloudStorage(audioPath: string): Promise<string> {
    try {
      const fileName = `audio-${Date.now()}-${Math.random().toString(36).substring(2)}.mp3`
      const gcsUri = `gs://${this.bucketName}/${fileName}`
      
      Logger.info(`ğŸ“¤ å¼€å§‹ä¸Šä¼ æ–‡ä»¶åˆ°Cloud Storage: ${fileName}`)
      
      // è¯»å–éŸ³é¢‘æ–‡ä»¶
      const fileBuffer = await fs.readFile(audioPath)
      Logger.debug(`ğŸ“Š æ–‡ä»¶å¤§å°: ${Math.round(fileBuffer.length / 1024 / 1024 * 100) / 100}MB`)
      
      const accessToken = await this.getAccessToken()
      const proxyConfig = await this.getProxyConfig()
      
      // æ„å»ºä¸Šä¼ è¯·æ±‚é…ç½®
      const uploadConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'audio/mpeg',
          'Content-Length': fileBuffer.length.toString()
        },
        timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
        maxBodyLength: Infinity,
        maxContentLength: Infinity
      }
      
      if (proxyConfig) {
        uploadConfig.proxy = proxyConfig
        Logger.debug(`ğŸŒ ä½¿ç”¨ä»£ç†ä¸Šä¼ : ${proxyConfig.host}:${proxyConfig.port}`)
      }
      
      // ä¸Šä¼ åˆ°Google Cloud Storage
      const uploadUrl = `https://storage.googleapis.com/upload/storage/v1/b/${this.bucketName}/o?uploadType=media&name=${fileName}`
      
      const startTime = Date.now()
      await axios.put(uploadUrl, fileBuffer, uploadConfig)
      const uploadDuration = Date.now() - startTime
      
      Logger.info(`âœ… æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: ${gcsUri}`)
      Logger.info(`â±ï¸ ä¸Šä¼ è€—æ—¶: ${uploadDuration}ms`)
      
      return gcsUri
      
    } catch (error: any) {
      Logger.error(`âŒ Cloud Storageä¸Šä¼ å¤±è´¥: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTPçŠ¶æ€: ${error.response.status}`)
        Logger.error(`  - å“åº”æ•°æ®: ${JSON.stringify(error.response.data, null, 2)}`)
      }
      throw new Error(`Cloud Storageä¸Šä¼ å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * åˆ é™¤Cloud Storageä¸­çš„æ–‡ä»¶
   */
  private async deleteFromCloudStorage(gcsUri: string): Promise<void> {
    try {
      const fileName = gcsUri.replace(`gs://${this.bucketName}/`, '')
      Logger.debug(`ğŸ—‘ï¸ æ¸…ç†Cloud Storageæ–‡ä»¶: ${fileName}`)
      
      const accessToken = await this.getAccessToken()
      const proxyConfig = await this.getProxyConfig()
      
      const deleteConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`
        },
        timeout: 30000
      }
      
      if (proxyConfig) {
        deleteConfig.proxy = proxyConfig
      }
      
      const deleteUrl = `https://storage.googleapis.com/storage/v1/b/${this.bucketName}/o/${encodeURIComponent(fileName)}`
      await axios.delete(deleteUrl, deleteConfig)
      
      Logger.debug(`âœ… Cloud Storageæ–‡ä»¶å·²åˆ é™¤: ${fileName}`)
      
    } catch (error: any) {
      Logger.warn(`âš ï¸ Cloud Storageæ–‡ä»¶åˆ é™¤å¤±è´¥: ${error.message}`)
      // åˆ é™¤å¤±è´¥ä¸å½±å“ä¸»æµç¨‹ï¼Œåªè®°å½•è­¦å‘Š
    }
  }

  public static getInstance(): GoogleSpeechService {
    if (!GoogleSpeechService.instance) {
      GoogleSpeechService.instance = new GoogleSpeechService()
    }
    return GoogleSpeechService.instance
  }

  /**
   * åˆå§‹åŒ–æœåŠ¡é…ç½®
   */
  private async initialize(): Promise<void> {
    if (this.projectId) {
      Logger.debug('Google SpeechæœåŠ¡å·²åˆå§‹åŒ–')
      return
    }

    try {
      // åŠ è½½é…ç½®
      const projectId = await ConfigManager.get('GOOGLE_STT_PROJECT_ID')
      const credentialsPath = await ConfigManager.get('GOOGLE_STT_CREDENTIALS_PATH')
      const location = await ConfigManager.get('GOOGLE_STT_LOCATION')
      const bucketName = await ConfigManager.get('GOOGLE_STT_BUCKET_NAME')

      this.location = location || 'global'
      this.bucketName = bucketName || ''

      Logger.info(`Google STTé…ç½®çŠ¶æ€:`)
      Logger.info(`  - é¡¹ç›®ID: ${projectId ? `${projectId.substring(0, 8)}...` : 'æœªé…ç½®'}`)
      Logger.info(`  - å‡­æ®æ–‡ä»¶: ${credentialsPath || 'æœªé…ç½®'}`)
      Logger.info(`  - ä½ç½®: ${this.location}`)
      Logger.info(`  - å­˜å‚¨æ¡¶: ${this.bucketName || 'æœªé…ç½®'}`)

      if (!projectId || !credentialsPath) {
        Logger.error('âŒ Google Speech-to-Text APIé…ç½®ä¸å®Œæ•´ï¼ŒæœåŠ¡ä¸å¯ç”¨ï¼')
        Logger.error('è¯·é…ç½® GOOGLE_STT_PROJECT_ID å’Œ GOOGLE_STT_CREDENTIALS_PATH')
        return
      }

      if (!this.bucketName) {
        Logger.warn('âš ï¸ Google Cloud Storageå­˜å‚¨æ¡¶æœªé…ç½®ï¼Œå¤§æ–‡ä»¶(>=10MB)å°†æ— æ³•å¤„ç†')
        Logger.warn('è¯·é…ç½® GOOGLE_STT_BUCKET_NAME ä»¥æ”¯æŒå¤§æ–‡ä»¶è½¬å½•')
      }

      // åŠ è½½æœåŠ¡è´¦æˆ·å‡­æ®
      await this.loadCredentials(credentialsPath)
      this.projectId = projectId

      if (this.credentials) {
        Logger.info('âœ… Google Speech-to-Text APIé…ç½®å®Œæˆ')
        
        // æµ‹è¯•ç½‘ç»œè¿æ¥
        Logger.debug('ğŸŒ æµ‹è¯•Google APIç½‘ç»œè¿é€šæ€§...')
        try {
          const testStart = Date.now()
          const proxyConfig = await this.getProxyConfig()
          const testRequestConfig: any = {
            timeout: 5000,
            validateStatus: () => true // æ¥å—ä»»ä½•çŠ¶æ€ç 
          }

          if (proxyConfig) {
            testRequestConfig.proxy = proxyConfig
          }

          const response = await axios.get('https://www.googleapis.com', testRequestConfig)
          const connectTime = Date.now() - testStart
          Logger.debug(`âœ… Google APIç½‘ç»œè¿é€šæ­£å¸¸ï¼Œå»¶è¿Ÿ: ${connectTime}ms`)
          Logger.debug(`  - çŠ¶æ€ç : ${response.status}`)
        } catch (networkError: any) {
          Logger.warn(`âš ï¸ Google APIç½‘ç»œè¿æ¥æµ‹è¯•å¤±è´¥: ${networkError.message}`)
          Logger.warn(`  - è¿™å¯èƒ½ä¼šå½±å“åç»­çš„è®¤è¯å’ŒAPIè°ƒç”¨`)
          if (networkError.code === 'ENOTFOUND') {
            Logger.warn(`  - DNSè§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥`)
          } else if (networkError.code === 'ECONNREFUSED') {
            Logger.warn(`  - è¿æ¥è¢«æ‹’ç»ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé˜²ç«å¢™é—®é¢˜`)
          } else if (networkError.code === 'ETIMEDOUT') {
            Logger.warn(`  - è¿æ¥è¶…æ—¶ï¼Œç½‘ç»œå»¶è¿Ÿè¾ƒé«˜`)
          }
        }
      }

    } catch (error: any) {
      Logger.error(`Google SpeechæœåŠ¡åˆå§‹åŒ–å¤±è´¥: ${error.message}`)
      throw new Error(`Google SpeechæœåŠ¡åˆå§‹åŒ–å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * åŠ è½½GoogleæœåŠ¡è´¦æˆ·å‡­æ®
   */
  private async loadCredentials(credentialsPath: string): Promise<void> {
    try {
      Logger.debug(`ğŸ“ å°è¯•è¯»å–å‡­æ®æ–‡ä»¶: ${credentialsPath}`)
      
      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
      try {
        await fs.access(credentialsPath)
        Logger.debug(`âœ… å‡­æ®æ–‡ä»¶å­˜åœ¨`)
      } catch (accessError) {
        throw new Error(`å‡­æ®æ–‡ä»¶ä¸å­˜åœ¨: ${credentialsPath}`)
      }
      
      const credentialsContent = await fs.readFile(credentialsPath, 'utf-8')
      Logger.debug(`ğŸ“„ å‡­æ®æ–‡ä»¶è¯»å–æˆåŠŸï¼Œå†…å®¹é•¿åº¦: ${credentialsContent.length}å­—ç¬¦`)
      
      // è§£æJSON
      let parsedCredentials: any
      try {
        parsedCredentials = JSON.parse(credentialsContent)
        Logger.debug(`âœ… JSONè§£ææˆåŠŸ`)
      } catch (parseError) {
        throw new Error(`å‡­æ®æ–‡ä»¶JSONæ ¼å¼é”™è¯¯: ${parseError}`)
      }
      
      this.credentials = parsedCredentials as GoogleCredentials
      
      Logger.debug(`âœ… GoogleæœåŠ¡è´¦æˆ·å‡­æ®åŠ è½½æˆåŠŸ: ${this.credentials.client_email}`)
      Logger.debug(`ğŸ“‹ å‡­æ®ä¿¡æ¯:`)
      Logger.debug(`  - ç±»å‹: ${this.credentials.type}`)
      Logger.debug(`  - é¡¹ç›®ID: ${this.credentials.project_id}`)
      Logger.debug(`  - å®¢æˆ·ç«¯é‚®ç®±: ${this.credentials.client_email}`)
      Logger.debug(`  - å®¢æˆ·ç«¯ID: ${this.credentials.client_id}`)
      Logger.debug(`  - ç§é’¥ID: ${this.credentials.private_key_id}`)
      Logger.debug(`  - è®¤è¯URI: ${this.credentials.auth_uri}`)
      Logger.debug(`  - Token URI: ${this.credentials.token_uri}`)
      
      // éªŒè¯å¿…è¦å­—æ®µ
      const requiredFields = ['private_key', 'client_email', 'project_id', 'token_uri']
      const missingFields = requiredFields.filter(field => !this.credentials![field as keyof GoogleCredentials])
      
      if (missingFields.length > 0) {
        throw new Error(`æœåŠ¡è´¦æˆ·å‡­æ®ç¼ºå°‘å¿…è¦å­—æ®µ: ${missingFields.join(', ')}`)
      }
      
      // éªŒè¯ç§é’¥æ ¼å¼
      if (!this.credentials.private_key.includes('-----BEGIN PRIVATE KEY-----')) {
        throw new Error('ç§é’¥æ ¼å¼ä¸æ­£ç¡®')
      }
      
      Logger.debug(`âœ… å‡­æ®éªŒè¯é€šè¿‡`)

    } catch (error: any) {
      Logger.error(`âŒ åŠ è½½Googleå‡­æ®å¤±è´¥: ${error.message}`)
      if (error.code === 'ENOENT') {
        Logger.error(`  - æ–‡ä»¶è·¯å¾„: ${credentialsPath}`)
        Logger.error(`  - è¯·ç¡®ä¿å‡­æ®æ–‡ä»¶å­˜åœ¨ä¸”è·¯å¾„æ­£ç¡®`)
      }
      throw new Error(`åŠ è½½Googleå‡­æ®å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * è·å–Google Access Token (JWTè®¤è¯)
   */
  private async getAccessToken(): Promise<string> {
    // å¦‚æœtokenè¿˜æœªè¿‡æœŸï¼Œç›´æ¥è¿”å›
    if (this.accessToken && Date.now() < this.tokenExpiration) {
      return this.accessToken
    }

    return await this.refreshAccessToken()
  }

  /**
   * åˆ·æ–°Access Token
   */
  private async refreshAccessToken(): Promise<string> {
    if (!this.credentials) {
      throw new Error('Googleå‡­æ®æœªåŠ è½½')
    }

    try {
      Logger.debug('ğŸ” å¼€å§‹è·å–Google Access Token...')
      Logger.debug(`ğŸ”‘ ä½¿ç”¨æœåŠ¡è´¦æˆ·: ${this.credentials.client_email}`)
      Logger.debug(`ğŸ“‹ é¡¹ç›®ID: ${this.credentials.project_id}`)

      // ç”ŸæˆJWT
      Logger.debug('ğŸ”§ ç”ŸæˆJWT Token...')
      const jwt = await this.generateJWT()
      Logger.debug(`âœ… JWTç”ŸæˆæˆåŠŸï¼Œé•¿åº¦: ${jwt.length}å­—ç¬¦`)

      // è¯·æ±‚access token
      Logger.debug('ğŸ“¡ å‘é€OAuthè¯·æ±‚åˆ°Google...')
      const startTime = Date.now()
      
      const proxyConfig = await this.getProxyConfig()
      const requestConfig: any = {
        headers: {
          'Content-Type': 'application/x-www-form-urlencoded'
        },
        timeout: 30000
      }

      if (proxyConfig) {
        requestConfig.proxy = proxyConfig
        Logger.debug(`ğŸŒ ä½¿ç”¨ä»£ç†: ${proxyConfig.host}:${proxyConfig.port}`)
      }

      const response = await axios.post('https://oauth2.googleapis.com/token', {
        grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
        assertion: jwt
      }, requestConfig)

      const requestDuration = Date.now() - startTime
      Logger.debug(`ğŸ“¡ OAuthè¯·æ±‚å®Œæˆï¼Œè€—æ—¶: ${requestDuration}ms`)

      const { access_token, expires_in } = response.data
      
      this.accessToken = access_token
      this.tokenExpiration = Date.now() + (expires_in * 1000) - 60000 // æå‰1åˆ†é’Ÿè¿‡æœŸ

      Logger.debug(`âœ… Google Access Tokenè·å–æˆåŠŸ`)
      Logger.debug(`  - Tokené•¿åº¦: ${access_token.length}å­—ç¬¦`)
      Logger.debug(`  - æœ‰æ•ˆæœŸ: ${expires_in}ç§’`)
      Logger.debug(`  - è¿‡æœŸæ—¶é—´: ${new Date(this.tokenExpiration).toLocaleString()}`)
      
      return access_token

    } catch (error: any) {
      Logger.error(`âŒ è·å–Google Access Tokenå¤±è´¥: ${error.message}`)
      
      // è¯¦ç»†é”™è¯¯ä¿¡æ¯
      if (error.code) {
        Logger.error(`  - é”™è¯¯ä»£ç : ${error.code}`)
      }
      if (error.response) {
        Logger.error(`  - HTTPçŠ¶æ€: ${error.response.status}`)
        Logger.error(`  - å“åº”æ•°æ®:`, error.response.data)
      }
      if (error.request) {
        Logger.error(`  - è¯·æ±‚é…ç½®:`, {
          url: error.request.responseURL || error.config?.url,
          method: error.config?.method,
          timeout: error.config?.timeout
        })
      }
      
      throw new Error(`Googleè®¤è¯å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * ç”ŸæˆJWT Token
   */
  private async generateJWT(): Promise<string> {
    if (!this.credentials) {
      throw new Error('Googleå‡­æ®æœªåŠ è½½')
    }

    try {
      Logger.debug('ğŸ”§ å¼€å§‹ç”ŸæˆJWT Token...')
      
      const now = Math.floor(Date.now() / 1000)
      const header = {
        alg: 'RS256',
        typ: 'JWT'
      }

      const payload = {
        iss: this.credentials.client_email,
        scope: 'https://www.googleapis.com/auth/cloud-platform',
        aud: 'https://oauth2.googleapis.com/token',
        exp: now + 3600, // 1å°æ—¶è¿‡æœŸ
        iat: now
      }

      Logger.debug(`ğŸ“‹ JWT Payload:`)
      Logger.debug(`  - ç­¾å‘è€…: ${payload.iss}`)
      Logger.debug(`  - æƒé™èŒƒå›´: ${payload.scope}`)
      Logger.debug(`  - ç›®æ ‡å—ä¼—: ${payload.aud}`)
      Logger.debug(`  - ç­¾å‘æ—¶é—´: ${new Date(payload.iat * 1000).toISOString()}`)
      Logger.debug(`  - è¿‡æœŸæ—¶é—´: ${new Date(payload.exp * 1000).toISOString()}`)

      // ä½¿ç”¨Node.jså†…ç½®cryptoæ¨¡å—ç”ŸæˆJWT
      const crypto = require('crypto')
      
      Logger.debug('ğŸ”§ ç¼–ç JWTå¤´éƒ¨å’Œè½½è·...')
      const headerBase64 = Buffer.from(JSON.stringify(header)).toString('base64url')
      const payloadBase64 = Buffer.from(JSON.stringify(payload)).toString('base64url')
      
      const signatureInput = `${headerBase64}.${payloadBase64}`
      Logger.debug(`ğŸ“ å¾…ç­¾åå­—ç¬¦ä¸²é•¿åº¦: ${signatureInput.length}å­—ç¬¦`)
      
      // æ¸…ç†private keyæ ¼å¼
      Logger.debug('ğŸ”‘ å¤„ç†ç§é’¥æ ¼å¼...')
      const privateKey = this.credentials.private_key.replace(/\\n/g, '\n')
      Logger.debug(`ğŸ”‘ ç§é’¥é•¿åº¦: ${privateKey.length}å­—ç¬¦`)
      
      // éªŒè¯ç§é’¥æ ¼å¼
      if (!privateKey.includes('-----BEGIN PRIVATE KEY-----')) {
        throw new Error('ç§é’¥æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘BEGINæ ‡è®°')
      }
      if (!privateKey.includes('-----END PRIVATE KEY-----')) {
        throw new Error('ç§é’¥æ ¼å¼ä¸æ­£ç¡®ï¼Œç¼ºå°‘ENDæ ‡è®°')
      }
      
      Logger.debug('ğŸ” ç”ŸæˆRSA-SHA256ç­¾å...')
      const signature = crypto.sign('RSA-SHA256', Buffer.from(signatureInput), {
        key: privateKey,
        padding: crypto.constants.RSA_PKCS1_PADDING
      })
      
      const signatureBase64 = signature.toString('base64url')
      Logger.debug(`âœ… ç­¾åç”ŸæˆæˆåŠŸï¼Œé•¿åº¦: ${signatureBase64.length}å­—ç¬¦`)
      
      const jwt = `${signatureInput}.${signatureBase64}`
      Logger.debug(`âœ… JWTç”Ÿæˆå®Œæˆï¼Œæ€»é•¿åº¦: ${jwt.length}å­—ç¬¦`)
      
      return jwt
      
    } catch (error: any) {
      Logger.error(`âŒ JWTç”Ÿæˆå¤±è´¥: ${error.message}`)
      if (error.stack) {
        Logger.error(`  - å †æ ˆä¿¡æ¯: ${error.stack}`)
      }
      throw new Error(`JWTç”Ÿæˆå¤±è´¥: ${error.message}`)
    }
  }

  /**
   * åˆ¤æ–­æ˜¯å¦ä½¿ç”¨åŒæ­¥è¯†åˆ«ï¼ˆ10MBä¸ºç•Œé™ï¼‰
   */
  private shouldUseSyncRecognition(fileSize?: number): boolean {
    const SYNC_THRESHOLD_BYTES = 10 * 1024 * 1024 // 10MB

    // å¦‚æœæ— æ³•è·å–æ–‡ä»¶å¤§å°ä¿¡æ¯ï¼Œé»˜è®¤ä½¿ç”¨åŒæ­¥
    if (!fileSize) {
      Logger.info('ğŸ”„ æ— æ³•è·å–éŸ³é¢‘æ–‡ä»¶å¤§å°ï¼Œé»˜è®¤ä½¿ç”¨åŒæ­¥è¯†åˆ«')
      return true
    }

    const fileSizeMB = Math.round(fileSize / 1024 / 1024 * 100) / 100
    
    // å¦‚æœæ–‡ä»¶å¤§å°è¶…è¿‡10MBä½†æ²¡æœ‰é…ç½®å­˜å‚¨æ¡¶ï¼Œå¼ºåˆ¶ä½¿ç”¨åŒæ­¥ï¼ˆä¼šå¤±è´¥ï¼Œä½†ç»™å‡ºæ˜ç¡®é”™è¯¯ï¼‰
    if (fileSize > SYNC_THRESHOLD_BYTES && !this.bucketName) {
      Logger.error(`âŒ æ–‡ä»¶å¤§å°${fileSizeMB}MBè¶…è¿‡10MBé™åˆ¶ï¼Œä½†æœªé…ç½®Cloud Storageå­˜å‚¨æ¡¶`)
      Logger.error('è¯·é…ç½® GOOGLE_STT_BUCKET_NAME ç¯å¢ƒå˜é‡ä»¥æ”¯æŒå¤§æ–‡ä»¶è½¬å½•')
      throw new Error(`æ–‡ä»¶å¤§å°${fileSizeMB}MBè¶…è¿‡10MBé™åˆ¶ï¼Œéœ€è¦é…ç½®Google Cloud Storage`)
    }
    
    const useSync = fileSize <= SYNC_THRESHOLD_BYTES
    Logger.info(`ğŸ¯ éŸ³é¢‘æ–‡ä»¶å¤§å°: ${fileSizeMB}MB, é€‰æ‹©${useSync ? 'åŒæ­¥' : 'å¼‚æ­¥(Cloud Storage)'}è¯†åˆ«`)
    return useSync
  }

  /**
   * åŒæ­¥è¯­éŸ³è¯†åˆ«ï¼ˆå°æ–‡ä»¶ï¼Œ<10MBï¼‰
   */
  private async syncRecognize(audioPath: string): Promise<string> {
    try {
      Logger.info(`ğŸ¤ å¼€å§‹GoogleåŒæ­¥è¯­éŸ³è¯†åˆ«: ${audioPath}`)

      const accessToken = await this.getAccessToken()
      
      // è¯»å–å¹¶ç¼–ç éŸ³é¢‘æ–‡ä»¶
      const audioBuffer = await fs.readFile(audioPath)
      const base64Audio = audioBuffer.toString('base64')
      Logger.info(`ğŸ“¦ éŸ³é¢‘ç¼–ç å®Œæˆï¼Œå¤§å°: ${Math.round(audioBuffer.length / 1024 / 1024 * 100) / 100}MB`)

      // æ„å»ºè¯·æ±‚
      const request: SyncRecognitionRequest = {
        config: this.buildRecognitionConfig(false),
        audio: {
          content: base64Audio
        }
      }

      Logger.info(`ğŸš€ æäº¤GoogleåŒæ­¥è¯†åˆ«ä»»åŠ¡...`)
      Logger.debug(`  - è¯­è¨€: ${request.config.languageCode}`)
      Logger.debug(`  - æ¨¡å‹: ${request.config.model}`)
      Logger.debug(`  - é‡‡æ ·ç‡: ${request.config.sampleRateHertz}Hz`)

      const proxyConfig = await this.getProxyConfig()
      const requestConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        timeout: 300000 // 5åˆ†é’Ÿè¶…æ—¶
      }
      
      if (proxyConfig) {
        requestConfig.proxy = proxyConfig
      }

      const startTime = Date.now()
      const response = await axios.post<SyncRecognitionResponse>(
        'https://speech.googleapis.com/v1/speech:recognize',
        request,
        requestConfig
      )

      const duration = Date.now() - startTime
      Logger.info(`ğŸ“¦ GoogleåŒæ­¥è¯†åˆ«å“åº”æ¥æ”¶å®Œæˆï¼Œè€—æ—¶: ${duration}ms`)

      // è§£æç»“æœ
      const transcription = this.parseRecognitionResponse(response.data)
      Logger.info(`âœ… GoogleåŒæ­¥è¯­éŸ³è¯†åˆ«æˆåŠŸ - æ–‡æœ¬é•¿åº¦: ${transcription.length}å­—ç¬¦`)
      
      return transcription

    } catch (error: any) {
      Logger.error(`âŒ GoogleåŒæ­¥è¯­éŸ³è¯†åˆ«å¤±è´¥: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTPçŠ¶æ€: ${error.response.status}`)
        Logger.error(`  - å“åº”æ•°æ®: ${JSON.stringify(error.response.data, null, 2)}`)
      }
      throw new Error(`GoogleåŒæ­¥è¯­éŸ³è¯†åˆ«å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * å¼‚æ­¥è¯­éŸ³è¯†åˆ«ï¼ˆå¤§æ–‡ä»¶ï¼Œ>=10MBï¼Œä½¿ç”¨Cloud Storageï¼‰
   */
  private async longRunningRecognize(audioPath: string): Promise<string> {
    let gcsUri: string | null = null
    
    try {
      Logger.info(`ğŸ¤ å¼€å§‹Googleå¼‚æ­¥è¯­éŸ³è¯†åˆ«: ${audioPath}`)

      // ä¸Šä¼ æ–‡ä»¶åˆ°Cloud Storage
      gcsUri = await this.uploadToCloudStorage(audioPath)
      
      const accessToken = await this.getAccessToken()
      
      // æ„å»ºè¯·æ±‚
      const request: LongRunningRecognitionRequest = {
        config: this.buildRecognitionConfig(true),
        audio: {
          uri: gcsUri
        }
      }

      Logger.info(`ğŸš€ æäº¤Googleå¼‚æ­¥è¯†åˆ«ä»»åŠ¡...`)
      Logger.debug(`  - è¯­è¨€: ${request.config.languageCode}`)
      Logger.debug(`  - æ¨¡å‹: ${request.config.model}`)
      Logger.debug(`  - Cloud Storage URI: ${gcsUri}`)

      const proxyConfig = await this.getProxyConfig()
      const requestConfig: any = {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        timeout: 300000 // 5åˆ†é’Ÿè¶…æ—¶
      }
      
      if (proxyConfig) {
        requestConfig.proxy = proxyConfig
      }

      const startTime = Date.now()
      const response = await axios.post<Operation>(
        'https://speech.googleapis.com/v1/speech:longrunningrecognize',
        request,
        requestConfig
      )

      const duration = Date.now() - startTime
      Logger.info(`ğŸ“¦ Googleå¼‚æ­¥ä»»åŠ¡æäº¤æˆåŠŸï¼Œè€—æ—¶: ${duration}ms`)
      Logger.info(`  - æ“ä½œåç§°: ${response.data.name}`)

      // è½®è¯¢ç­‰å¾…ç»“æœ
      const operationName = response.data.name
      const result = await this.pollLongRunningOperation(operationName)
      
      // è§£æç»“æœ
      if (!result.response?.results) {
        throw new Error('å¼‚æ­¥è¯†åˆ«æ“ä½œå®Œæˆï¼Œä½†æ²¡æœ‰è¿”å›è¯†åˆ«ç»“æœ')
      }
      
      const transcription = this.parseRecognitionResponse(result.response)
      Logger.info(`âœ… Googleå¼‚æ­¥è¯­éŸ³è¯†åˆ«æˆåŠŸ - æ–‡æœ¬é•¿åº¦: ${transcription.length}å­—ç¬¦`)
      
      return transcription

    } catch (error: any) {
      Logger.error(`âŒ Googleå¼‚æ­¥è¯­éŸ³è¯†åˆ«å¤±è´¥: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTPçŠ¶æ€: ${error.response.status}`)
        Logger.error(`  - å“åº”æ•°æ®: ${JSON.stringify(error.response.data, null, 2)}`)
      }
      throw new Error(`Googleå¼‚æ­¥è¯­éŸ³è¯†åˆ«å¤±è´¥: ${error.message}`)
    } finally {
      // æ¸…ç†Cloud Storageæ–‡ä»¶
      if (gcsUri) {
        try {
          await this.deleteFromCloudStorage(gcsUri)
        } catch (cleanupError) {
          Logger.warn(`âš ï¸ æ¸…ç†Cloud Storageæ–‡ä»¶å¤±è´¥: ${cleanupError}`)
        }
      }
    }
  }

  /**
   * è½®è¯¢é•¿è¿è¡Œæ“ä½œçŠ¶æ€
   */
  private async pollLongRunningOperation(operationName: string): Promise<Operation> {
    const maxAttempts = 60 // æœ€å¤§è½®è¯¢æ¬¡æ•°
    const initialDelay = 5000 // åˆå§‹å»¶è¿Ÿ5ç§’
    const maxDelay = 30000 // æœ€å¤§å»¶è¿Ÿ30ç§’
    
    Logger.info(`ğŸ”„ å¼€å§‹è½®è¯¢å¼‚æ­¥æ“ä½œçŠ¶æ€: ${operationName}`)
    
    for (let attempt = 1; attempt <= maxAttempts; attempt++) {
      try {
        const operation = await this.queryOperation(operationName)
        
        if (operation.done) {
          if (operation.error) {
            Logger.error(`âŒ å¼‚æ­¥æ“ä½œå¤±è´¥: ${JSON.stringify(operation.error)}`)
            throw new Error(`å¼‚æ­¥æ“ä½œå¤±è´¥: ${operation.error.message || 'æœªçŸ¥é”™è¯¯'}`)
          }
          
          Logger.info(`âœ… å¼‚æ­¥æ“ä½œå®Œæˆï¼Œå…±è½®è¯¢${attempt}æ¬¡`)
          return operation
        }
        
        // è®¡ç®—åŠ¨æ€å»¶è¿Ÿæ—¶é—´ï¼ˆæŒ‡æ•°é€€é¿ï¼‰
        const delay = Math.min(initialDelay * Math.pow(1.5, attempt - 1), maxDelay)
        Logger.debug(`â³ æ“ä½œæœªå®Œæˆï¼Œ${delay}msåè¿›è¡Œç¬¬${attempt + 1}æ¬¡æŸ¥è¯¢...`)
        
        await new Promise(resolve => setTimeout(resolve, delay))
        
      } catch (error: any) {
        Logger.error(`âŒ æŸ¥è¯¢æ“ä½œçŠ¶æ€å¤±è´¥(ç¬¬${attempt}æ¬¡): ${error.message}`)
        
        if (attempt === maxAttempts) {
          throw new Error(`è½®è¯¢æ“ä½œçŠ¶æ€å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°: ${error.message}`)
        }
        
        // æŸ¥è¯¢å¤±è´¥æ—¶ç­‰å¾…è¾ƒçŸ­æ—¶é—´å†é‡è¯•
        await new Promise(resolve => setTimeout(resolve, 2000))
      }
    }
    
    throw new Error(`å¼‚æ­¥æ“ä½œè¶…æ—¶ï¼Œå·²è½®è¯¢${maxAttempts}æ¬¡ä»æœªå®Œæˆ`)
  }

  /**
   * æŸ¥è¯¢å¼‚æ­¥æ“ä½œçŠ¶æ€
   */
  private async queryOperation(operationName: string): Promise<Operation> {
    const accessToken = await this.getAccessToken()
    const proxyConfig = await this.getProxyConfig()
    
    const requestConfig: any = {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000 // 30ç§’è¶…æ—¶
    }
    
    if (proxyConfig) {
      requestConfig.proxy = proxyConfig
    }

    const response = await axios.get<Operation>(
      `https://speech.googleapis.com/v1/${operationName}`,
      requestConfig
    )

    return response.data
  }

  /**
   * æ„å»ºè¯†åˆ«é…ç½®
   */
  private buildRecognitionConfig(isLongRunning: boolean = false): RecognitionConfig {
    return {
      encoding: 'MP3',
      sampleRateHertz: 16000,
      audioChannelCount: 1,
      languageCode: 'zh-CN',
      alternativeLanguageCodes: ['en-US', 'ja-JP'], // æ”¯æŒä¸­è‹±æ—¥æ–‡
      enableAutomaticPunctuation: true,
      model: isLongRunning ? 'latest_long' : 'latest_short'
    }
  }


  /**
   * è§£æè¯†åˆ«å“åº”ç»“æœ
   */
  private parseRecognitionResponse(response: SyncRecognitionResponse | { results: SpeechRecognitionResult[] }): string {
    try {
      // è·å–è®¿é—®ä»¤ç‰Œ
      const accessToken = await this.getAccessToken()

      // è¯»å–å’Œç¼–ç éŸ³é¢‘æ–‡ä»¶
      const audioBuffer = await fs.readFile(audioPath)
      const audioContent = audioBuffer.toString('base64')

      Logger.info(`ğŸ“¦ éŸ³é¢‘ç¼–ç å®Œæˆï¼Œå¤§å°: ${Math.round(audioBuffer.length / 1024 / 1024 * 100) / 100}MB`)

      const request: LongRunningRecognitionRequest = {
        config: this.buildRecognitionConfig(true),
        audio: { content: audioContent }
      }

      Logger.info(`ğŸš€ æäº¤Googleå¼‚æ­¥è¯†åˆ«ä»»åŠ¡...`)
      Logger.debug(`  - è¯­è¨€: ${request.config.languageCode}`)
      Logger.debug(`  - æ¨¡å‹: ${request.config.model}`)

      const startTime = Date.now()
      const response = await axios.post<Operation>(
        'https://speech.googleapis.com/v1/speech:longrunningrecognize',
        request,
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'Content-Type': 'application/json'
          },
          timeout: 300000, // 5åˆ†é’Ÿè¶…æ—¶
          proxy: {
            host: '127.0.0.1',
            port: 7890,
            protocol: 'http'
          }
        }
      )

      const duration = Date.now() - startTime
      Logger.info(`ğŸ“¦ Googleå¼‚æ­¥ä»»åŠ¡æäº¤æˆåŠŸï¼Œè€—æ—¶: ${duration}ms`)
      Logger.info(`  - æ“ä½œåç§°: ${response.data.name}`)

      return response.data.name

    } catch (error: any) {
      Logger.error(`âŒ æäº¤Googleå¼‚æ­¥ä»»åŠ¡å¤±è´¥: ${error.message}`)
      if (error.response) {
        Logger.error(`  - HTTPçŠ¶æ€: ${error.response.status}`)
        Logger.error(`  - å“åº”æ•°æ®:`, error.response.data)
      }
      throw new Error(`æäº¤Googleå¼‚æ­¥ä»»åŠ¡å¤±è´¥: ${error.message}`)
    }
  }

  /**
   * è½®è¯¢å¼‚æ­¥æ“ä½œç»“æœï¼ˆå¤ç”¨è±†åŒ…çš„è½®è¯¢ç­–ç•¥ï¼‰
   */
  private async pollLongRunningOperation(operationName: string): Promise<string> {
    const maxRetries = 80 // 80æ¬¡è½®è¯¢
    const baseInterval = 30000 // 30ç§’åŸºç¡€é—´éš”
    const maxWaitTime = maxRetries * baseInterval

    Logger.info(`ğŸ”„ å¼€å§‹è½®è¯¢Google Speechå¼‚æ­¥ä»»åŠ¡:`)
    Logger.info(`  - æ“ä½œåç§°: ${operationName}`)
    Logger.info(`  - æœ€å¤§è½®è¯¢æ¬¡æ•°: ${maxRetries}`)
    Logger.info(`  - è½®è¯¢é—´éš”: ${baseInterval/1000}ç§’`)
    Logger.info(`  - æœ€å¤§ç­‰å¾…æ—¶é—´: ${Math.round(maxWaitTime/60000)}åˆ†é’Ÿ`)

    for (let i = 0; i < maxRetries; i++) {
      // å¤ç”¨è±†åŒ…çš„åŠ¨æ€é—´éš”é€»è¾‘ï¼šå‰5æ¬¡å¿«é€Ÿï¼Œåç»­æ­£å¸¸
      const currentInterval = i < 5 ? Math.max(baseInterval / 2, 15000) : baseInterval
      await new Promise(resolve => setTimeout(resolve, currentInterval))

      const progress = Math.round((i + 1) / maxRetries * 100)
      Logger.info(`ğŸ“Š æŸ¥è¯¢Googleå¼‚æ­¥ä»»åŠ¡çŠ¶æ€ (${i + 1}/${maxRetries}, ${progress}%): é—´éš”: ${currentInterval}ms`)

      try {
        const startTime = Date.now()
        const operation = await this.queryOperation(operationName)
        const queryTime = Date.now() - startTime

        Logger.debug(`ğŸ” æŸ¥è¯¢å“åº”æ—¶é—´: ${queryTime}ms`)

        if (operation.done) {
          if (operation.error) {
            Logger.error(`ğŸ’¥ Googleå¼‚æ­¥ä»»åŠ¡å¤±è´¥:`)
            Logger.error(`  - é”™è¯¯ä»£ç : ${operation.error.code}`)
            Logger.error(`  - é”™è¯¯æ¶ˆæ¯: ${operation.error.message}`)
            throw new Error(`Googleå¼‚æ­¥ä»»åŠ¡å¤±è´¥: ${operation.error.message}`)
          }

          if (operation.response) {
            const transcription = this.parseRecognitionResponse(operation.response)
            
            const totalElapsedTime = (i + 1) * currentInterval
            Logger.info(`ğŸ‰ Googleå¼‚æ­¥ä»»åŠ¡å®Œæˆ:`)
            Logger.info(`  - è½®è¯¢æ¬¡æ•°: ${i + 1}/${maxRetries}`)
            Logger.info(`  - æ€»è€—æ—¶: ${Math.round(totalElapsedTime / 1000)}ç§’`)
            Logger.info(`  - è½¬å½•é•¿åº¦: ${transcription.length}å­—ç¬¦`)
            Logger.info(`  - è½¬å½•é¢„è§ˆ: ${transcription.substring(0, 300)}${transcription.length > 300 ? '...' : ''}`)

            return transcription
          }
        }

        Logger.info(`ğŸ“ˆ Googleå¼‚æ­¥ä»»åŠ¡è¿›è¡Œä¸­ (${i + 1}/${maxRetries})`)

      } catch (error: any) {
        Logger.warn(`â° GoogleæŸ¥è¯¢å‡ºé”™ï¼Œå°†è¿›è¡Œé‡è¯• (${i + 1}/${maxRetries}): ${error.message}`)
        
        // å¦‚æœè¿ç»­å¤šæ¬¡å¤±è´¥ï¼ŒæŠ›å‡ºé”™è¯¯
        if (i >= 5 && error.message.includes('è®¤è¯') || error.message.includes('æˆæƒ')) {
          throw error
        }
      }
    }

    Logger.error(`ğŸ’€ Googleå¼‚æ­¥è¯†åˆ«ä»»åŠ¡è¶…æ—¶:`)
    Logger.error(`  - æ“ä½œåç§°: ${operationName}`)
    Logger.error(`  - å·²ç­‰å¾…æ—¶é—´: ${Math.round(maxWaitTime/60000)}åˆ†é’Ÿ`)
    
    throw new Error(`Googleå¼‚æ­¥è¯­éŸ³è¯†åˆ«ä»»åŠ¡è¶…æ—¶ï¼Œå·²ç­‰å¾…${Math.round(maxWaitTime/60000)}åˆ†é’Ÿ`)
  }

  /**
   * æŸ¥è¯¢å¼‚æ­¥æ“ä½œçŠ¶æ€
   */
  private async queryOperation(operationName: string): Promise<Operation> {
    const accessToken = await this.getAccessToken()

    const response = await axios.get<Operation>(
      `https://speech.googleapis.com/v1/${operationName}`,
      {
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json'
        },
        timeout: 30000, // 30ç§’è¶…æ—¶
        proxy: {
          host: '127.0.0.1',
          port: 1080,
          protocol: 'http'
        }
      }
    )

    return response.data
  }

  /**
   * è§£æè¯†åˆ«å“åº”ç»“æœ
   */
  private parseRecognitionResponse(response: SyncRecognitionResponse | { results: SpeechRecognitionResult[] }): string {
    if (!response.results || response.results.length === 0) {
      Logger.warn('Google Speechè¿”å›ç©ºç»“æœ')
      return ''
    }

    // åˆå¹¶æ‰€æœ‰resultsä¸­çš„æœ€ä½³è½¬å½•ç»“æœ
    const transcription = response.results
      .map(result => {
        const alternative = result.alternatives?.[0]
        if (alternative && alternative.transcript) {
          // è®°å½•ç½®ä¿¡åº¦ä¿¡æ¯
          if (alternative.confidence) {
            Logger.debug(`è½¬å½•ç‰‡æ®µç½®ä¿¡åº¦: ${(alternative.confidence * 100).toFixed(1)}%`)
          }
          return alternative.transcript
        }
        return ''
      })
      .filter(text => text.length > 0)
      .join(' ')
      .trim()

    Logger.info(`ğŸ“ Google Speechè½¬å½•ç»“æœè§£æå®Œæˆ: ${transcription.length}å­—ç¬¦`)
    
    if (transcription.length === 0) {
      Logger.warn('âš ï¸ è§£æåçš„è½¬å½•ç»“æœä¸ºç©º')
    }

    return transcription
  }

  /**
   * ä¸»å…¥å£ï¼šè¯­éŸ³è½¬æ–‡å­—
   */
  public async speechToText(audioPath: string): Promise<string> {
    try {
      Logger.info(`ğŸ¤ å¼€å§‹Google Speechè¯­éŸ³è¯†åˆ«: ${audioPath}`)

      // åˆå§‹åŒ–æœåŠ¡
      await this.initialize()

      if (!this.projectId || !this.credentials) {
        throw new Error('Google SpeechæœåŠ¡æœªæ­£ç¡®åˆå§‹åŒ–')
      }

      // éªŒè¯éŸ³é¢‘æ–‡ä»¶
      const isValid = await validateAudioFile(audioPath)
      if (!isValid) {
        throw new Error('éŸ³é¢‘æ–‡ä»¶éªŒè¯å¤±è´¥')
      }

      // è·å–éŸ³é¢‘ä¿¡æ¯
      const audioInfo = await getAudioFileInfo(audioPath)
      Logger.info(`ğŸ“Š éŸ³é¢‘æ–‡ä»¶ä¿¡æ¯:`)
      Logger.info(`  - æ—¶é•¿: ${audioInfo.duration ? `${audioInfo.duration}ç§’` : 'æœªçŸ¥'}`)
      Logger.info(`  - å¤§å°: ${Math.round(audioInfo.size / 1024 / 1024 * 100) / 100}MB`)
      Logger.info(`  - æ ¼å¼: ${audioInfo.format}`)

      // æ™ºèƒ½é€‰æ‹©åŒæ­¥æˆ–å¼‚æ­¥è¯†åˆ«ï¼ˆåŸºäºæ–‡ä»¶å¤§å°ï¼‰
      const useSync = this.shouldUseSyncRecognition(audioInfo.size)

      let transcription: string
      if (useSync) {
        transcription = await this.syncRecognize(audioPath)
      } else {
        transcription = await this.longRunningRecognize(audioPath)
      }

      if (!transcription || transcription.trim().length === 0) {
        Logger.error(`âŒ Google Speechè¯†åˆ«ç»“æœä¸ºç©º`)
        throw new Error('è¯­éŸ³è¯†åˆ«ç»“æœä¸ºç©º')
      }

      Logger.info(`âœ… Google Speechè¯­éŸ³è¯†åˆ«æˆåŠŸ - æ–‡æœ¬é•¿åº¦: ${transcription.length}å­—ç¬¦`)
      return transcription

    } catch (error: any) {
      Logger.error(`âŒ Google Speechè¯­éŸ³è½¬å½•å¤±è´¥: ${error.message}`)
      Logger.error(`ğŸ”§ é”™è¯¯è¯¦æƒ…: ${error.stack || 'No stack trace'}`)
      throw error
    }
  }

  /**
   * æ£€æŸ¥æœåŠ¡çŠ¶æ€
   */
  public async checkServiceStatus(): Promise<ServiceStatus> {
    try {
      await this.initialize()
      
      if (!this.projectId) {
        return { 
          available: false, 
          message: 'Google Speeché¡¹ç›®IDæœªé…ç½®' 
        }
      }

      if (!this.credentials) {
        return { 
          available: false, 
          message: 'Google Speechå‡­æ®æ–‡ä»¶æœªåŠ è½½' 
        }
      }

      // å°è¯•è·å–è®¿é—®ä»¤ç‰Œ
      const token = await this.getAccessToken()
      if (!token) {
        return { 
          available: false, 
          message: 'Google Speechè®¤è¯å¤±è´¥' 
        }
      }

      return { 
        available: true, 
        message: 'Google SpeechæœåŠ¡é…ç½®æ­£ç¡®' 
      }

    } catch (error: any) {
      return { 
        available: false, 
        message: `Google SpeechæœåŠ¡ä¸å¯ç”¨: ${error.message}` 
      }
    }
  }

  /**
   * è¯Šæ–­Google SpeechæœåŠ¡
   */
  public async diagnoseService(): Promise<DiagnosisResult> {
    const details = {
      configCheck: false,
      credentialsCheck: false,
      authCheck: false,
      apiConnectivity: false,
      suggestions: [] as string[]
    }

    let success = false

    try {
      Logger.info(`ğŸ”§ å¼€å§‹Google Speechè¯Šæ–­...`)

      // 1. é…ç½®æ£€æŸ¥
      try {
        const projectId = await ConfigManager.get('GOOGLE_STT_PROJECT_ID')
        const credentialsPath = await ConfigManager.get('GOOGLE_STT_CREDENTIALS_PATH')

        if (!projectId) {
          details.suggestions.push('è¯·é…ç½® GOOGLE_STT_PROJECT_ID')
        }
        if (!credentialsPath) {
          details.suggestions.push('è¯·é…ç½® GOOGLE_STT_CREDENTIALS_PATH')
        }

        details.configCheck = !!(projectId && credentialsPath)
        Logger.info(`âœ… é…ç½®æ£€æŸ¥: ${details.configCheck ? 'é€šè¿‡' : 'å¤±è´¥'}`)

      } catch (error: any) {
        Logger.error(`ğŸ’¥ é…ç½®æ£€æŸ¥å¤±è´¥: ${error.message}`)
        details.suggestions.push('æ£€æŸ¥ç¯å¢ƒå˜é‡é…ç½®')
      }

      // 2. å‡­æ®æ–‡ä»¶æ£€æŸ¥
      if (details.configCheck) {
        try {
          const credentialsPath = await ConfigManager.get('GOOGLE_STT_CREDENTIALS_PATH')
          await this.loadCredentials(credentialsPath!)
          details.credentialsCheck = true
          Logger.info(`âœ… å‡­æ®æ–‡ä»¶æ£€æŸ¥: é€šè¿‡`)

        } catch (error: any) {
          Logger.error(`ğŸ’¥ å‡­æ®æ–‡ä»¶æ£€æŸ¥å¤±è´¥: ${error.message}`)
          details.suggestions.push('æ£€æŸ¥GoogleæœåŠ¡è´¦æˆ·å‡­æ®æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®')
        }
      }

      // 3. è®¤è¯æ£€æŸ¥
      if (details.credentialsCheck) {
        try {
          const token = await this.getAccessToken()
          details.authCheck = !!token
          Logger.info(`âœ… è®¤è¯æ£€æŸ¥: ${details.authCheck ? 'é€šè¿‡' : 'å¤±è´¥'}`)

        } catch (error: any) {
          Logger.error(`ğŸ’¥ è®¤è¯æ£€æŸ¥å¤±è´¥: ${error.message}`)
          details.suggestions.push('æ£€æŸ¥Google Cloudé¡¹ç›®æƒé™å’ŒæœåŠ¡è´¦æˆ·é…ç½®')
        }
      }

      // 4. APIè¿é€šæ€§æ£€æŸ¥
      if (details.authCheck) {
        try {
          const accessToken = await this.getAccessToken()
          
          // å‘é€ä¸€ä¸ªç®€å•çš„è¯·æ±‚æµ‹è¯•è¿é€šæ€§
          await axios.get('https://speech.googleapis.com/v1/operations', {
            headers: {
              'Authorization': `Bearer ${accessToken}`
            },
            timeout: 15000,
            proxy: {
              host: '127.0.0.1',
              port: 7890,
              protocol: 'http'
            }
          })

          details.apiConnectivity = true
          Logger.info(`âœ… APIè¿é€šæ€§æ£€æŸ¥: é€šè¿‡`)

        } catch (error: any) {
          Logger.error(`ğŸ’¥ APIè¿é€šæ€§æ£€æŸ¥å¤±è´¥: ${error.message}`)
          details.suggestions.push('æ£€æŸ¥ç½‘ç»œè¿æ¥å’ŒGoogle Cloud Speech APIæ˜¯å¦å·²å¯ç”¨')
        }
      }

      success = details.configCheck && details.credentialsCheck && details.authCheck && details.apiConnectivity

      const resultMessage = success ? 'âœ… Google Speechè¯Šæ–­å…¨éƒ¨é€šè¿‡' : 'âš ï¸ å‘ç°é—®é¢˜ï¼Œè¯·æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯'
      
      Logger.info(`ğŸ¯ Google Speechè¯Šæ–­å®Œæˆ: ${success ? 'æˆåŠŸ' : 'å¤±è´¥'}`)

      return {
        success,
        message: resultMessage,
        details
      }

    } catch (error: any) {
      Logger.error(`ğŸ’€ Google Speechè¯Šæ–­è¿‡ç¨‹å‡ºé”™: ${error.message}`)
      
      return {
        success: false,
        message: `Google Speechè¯Šæ–­å¤±è´¥: ${error.message}`,
        details
      }
    }
  }
}

export default GoogleSpeechService
